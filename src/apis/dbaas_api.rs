/*
 * Exoscale Public API
 *
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{Deserialize, Serialize};
use crate::{models, utils,apis::ResponseContent};
use super::{Error, configuration};


/// struct for typed errors of method [`attach_dbaas_service_to_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttachDbaasServiceToEndpointError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_external_endpoint_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasExternalEndpointDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_external_endpoint_elasticsearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasExternalEndpointElasticsearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_external_endpoint_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasExternalEndpointOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_external_endpoint_prometheus`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasExternalEndpointPrometheusError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_external_endpoint_rsyslog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasExternalEndpointRsyslogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_kafka_schema_registry_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaSchemaRegistryAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_kafka_topic_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaTopicAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_kafka_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_mysql_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasMysqlDatabaseError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_mysql_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasMysqlUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_opensearch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasOpensearchUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_pg_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgDatabaseError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_pg_upgrade_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgUpgradeCheckError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_postgres_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPostgresUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServicePgError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_service_valkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceValkeyError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_task_migration_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasTaskMigrationCheckError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`create_dbaas_valkey_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasValkeyUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_external_endpoint_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasExternalEndpointDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_external_endpoint_elasticsearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasExternalEndpointElasticsearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_external_endpoint_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasExternalEndpointOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_external_endpoint_prometheus`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasExternalEndpointPrometheusError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_external_endpoint_rsyslog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasExternalEndpointRsyslogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_kafka_schema_registry_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaSchemaRegistryAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_kafka_topic_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaTopicAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_kafka_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_mysql_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasMysqlDatabaseError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_mysql_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasMysqlUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_opensearch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasOpensearchUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_pg_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPgDatabaseError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_postgres_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPostgresUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServicePgError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_service_valkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceValkeyError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`delete_dbaas_valkey_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasValkeyUserError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`detach_dbaas_service_from_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DetachDbaasServiceFromEndpointError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`enable_dbaas_mysql_writes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableDbaasMysqlWritesError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_ca_certificate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasCaCertificateError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_endpoint_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalEndpointDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_endpoint_elasticsearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalEndpointElasticsearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_endpoint_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalEndpointOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_endpoint_prometheus`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalEndpointPrometheusError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_endpoint_rsyslog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalEndpointRsyslogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalIntegrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_external_integration_settings_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasExternalIntegrationSettingsDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_kafka_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasKafkaAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_migration_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasMigrationStatusError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_opensearch_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasOpensearchAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceLogsError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceMetricsError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServicePgError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceTypeError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_service_valkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceValkeyError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsGrafanaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsKafkaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsMysqlError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsPgError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_settings_valkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsValkeyError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`get_dbaas_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasTaskError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_external_endpoint_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasExternalEndpointTypesError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_external_endpoints`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasExternalEndpointsError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_external_integrations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasExternalIntegrationsError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_integration_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasIntegrationSettingsError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_integration_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasIntegrationTypesError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_service_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasServiceTypesError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`list_dbaas_services`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasServicesError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_grafana_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasGrafanaUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_kafka_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasKafkaUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_mysql_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasMysqlUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_opensearch_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasOpensearchUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_postgres_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasPostgresUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reset_dbaas_valkey_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasValkeyUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_grafana_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasGrafanaUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_kafka_connect_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasKafkaConnectPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_kafka_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasKafkaUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_mysql_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasMysqlUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_opensearch_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasOpensearchUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_postgres_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasPostgresUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`reveal_dbaas_valkey_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealDbaasValkeyUserPasswordError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_grafana_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasGrafanaMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_kafka_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasKafkaMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_mysql_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasMysqlMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_opensearch_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasOpensearchMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_pg_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasPgMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`start_dbaas_valkey_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasValkeyMaintenanceError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`stop_dbaas_mysql_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasMysqlMigrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`stop_dbaas_pg_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasPgMigrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`stop_dbaas_valkey_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasValkeyMigrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_endpoint_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalEndpointDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_endpoint_elasticsearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalEndpointElasticsearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_endpoint_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalEndpointOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_endpoint_prometheus`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalEndpointPrometheusError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_endpoint_rsyslog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalEndpointRsyslogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_external_integration_settings_datadog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasExternalIntegrationSettingsDatadogError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_opensearch_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasOpensearchAclConfigError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_postgres_allow_replication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasPostgresAllowReplicationError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServicePgError {
    UnknownValue(serde_json::Value),
}


/// struct for typed errors of method [`update_dbaas_service_valkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceValkeyError {
    UnknownValue(serde_json::Value),
}


pub async fn attach_dbaas_service_to_endpoint(configuration: &configuration::Configuration, source_service_name: &str, attach_dbaas_service_to_endpoint_request: models::AttachDbaasServiceToEndpointRequest) -> Result<models::Operation, Error<AttachDbaasServiceToEndpointError>> {
    let local_var_source_service_name = source_service_name;
    let local_var_attach_dbaas_service_to_endpoint_request = attach_dbaas_service_to_endpoint_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("source_service_name".to_string(), crate::apis::urlencode(local_var_source_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_attach_dbaas_service_to_endpoint_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint/{source_service_name}/attach",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_external_endpoint_datadog(configuration: &configuration::Configuration, name: &str, dbaas_endpoint_datadog_input_create: models::DbaasEndpointDatadogInputCreate) -> Result<models::Operation, Error<CreateDbaasExternalEndpointDatadogError>> {
    let local_var_name = name;
    let local_var_dbaas_endpoint_datadog_input_create = dbaas_endpoint_datadog_input_create;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_datadog_input_create);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-endpoint-datadog/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_external_endpoint_elasticsearch(configuration: &configuration::Configuration, name: &str, dbaas_endpoint_elasticsearch_input_create: models::DbaasEndpointElasticsearchInputCreate) -> Result<models::Operation, Error<CreateDbaasExternalEndpointElasticsearchError>> {
    let local_var_name = name;
    let local_var_dbaas_endpoint_elasticsearch_input_create = dbaas_endpoint_elasticsearch_input_create;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_elasticsearch_input_create);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-endpoint-elasticsearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_external_endpoint_opensearch(configuration: &configuration::Configuration, name: &str, dbaas_endpoint_opensearch_input_create: models::DbaasEndpointOpensearchInputCreate) -> Result<models::Operation, Error<CreateDbaasExternalEndpointOpensearchError>> {
    let local_var_name = name;
    let local_var_dbaas_endpoint_opensearch_input_create = dbaas_endpoint_opensearch_input_create;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_opensearch_input_create);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-endpoint-opensearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_external_endpoint_prometheus(configuration: &configuration::Configuration, name: &str, dbaas_endpoint_prometheus_payload: models::DbaasEndpointPrometheusPayload) -> Result<models::Operation, Error<CreateDbaasExternalEndpointPrometheusError>> {
    let local_var_name = name;
    let local_var_dbaas_endpoint_prometheus_payload = dbaas_endpoint_prometheus_payload;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_prometheus_payload);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-endpoint-prometheus/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_external_endpoint_rsyslog(configuration: &configuration::Configuration, name: &str, dbaas_endpoint_rsyslog_input_create: models::DbaasEndpointRsyslogInputCreate) -> Result<models::Operation, Error<CreateDbaasExternalEndpointRsyslogError>> {
    let local_var_name = name;
    let local_var_dbaas_endpoint_rsyslog_input_create = dbaas_endpoint_rsyslog_input_create;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_rsyslog_input_create);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-endpoint-rsyslog/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_integration(configuration: &configuration::Configuration, create_dbaas_integration_request: models::CreateDbaasIntegrationRequest) -> Result<models::Operation, Error<CreateDbaasIntegrationError>> {
    let local_var_create_dbaas_integration_request = create_dbaas_integration_request;

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_integration_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-integration",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_kafka_schema_registry_acl_config(configuration: &configuration::Configuration, name: &str, dbaas_kafka_schema_registry_acl_entry: models::DbaasKafkaSchemaRegistryAclEntry) -> Result<models::Operation, Error<CreateDbaasKafkaSchemaRegistryAclConfigError>> {
    let local_var_name = name;
    let local_var_dbaas_kafka_schema_registry_acl_entry = dbaas_kafka_schema_registry_acl_entry;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_kafka_schema_registry_acl_entry);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-kafka/{name}/schema-registry/acl-config",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_kafka_topic_acl_config(configuration: &configuration::Configuration, name: &str, dbaas_kafka_topic_acl_entry: models::DbaasKafkaTopicAclEntry) -> Result<models::Operation, Error<CreateDbaasKafkaTopicAclConfigError>> {
    let local_var_name = name;
    let local_var_dbaas_kafka_topic_acl_entry = dbaas_kafka_topic_acl_entry;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_kafka_topic_acl_entry);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-kafka/{name}/topic/acl-config",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_kafka_user(configuration: &configuration::Configuration, service_name: &str, create_dbaas_kafka_user_request: models::CreateDbaasKafkaUserRequest) -> Result<models::Operation, Error<CreateDbaasKafkaUserError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_kafka_user_request = create_dbaas_kafka_user_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_kafka_user_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-kafka/{service_name}/user",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_mysql_database(configuration: &configuration::Configuration, service_name: &str, create_dbaas_mysql_database_request: models::CreateDbaasMysqlDatabaseRequest) -> Result<models::Operation, Error<CreateDbaasMysqlDatabaseError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_mysql_database_request = create_dbaas_mysql_database_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_mysql_database_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-mysql/{service_name}/database",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_mysql_user(configuration: &configuration::Configuration, service_name: &str, create_dbaas_mysql_user_request: models::CreateDbaasMysqlUserRequest) -> Result<models::Operation, Error<CreateDbaasMysqlUserError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_mysql_user_request = create_dbaas_mysql_user_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_mysql_user_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-mysql/{service_name}/user",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_opensearch_user(configuration: &configuration::Configuration, service_name: &str, create_dbaas_kafka_user_request: models::CreateDbaasKafkaUserRequest) -> Result<models::Operation, Error<CreateDbaasOpensearchUserError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_kafka_user_request = create_dbaas_kafka_user_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_kafka_user_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-opensearch/{service_name}/user",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_pg_connection_pool(configuration: &configuration::Configuration, service_name: &str, create_dbaas_pg_connection_pool_request: models::CreateDbaasPgConnectionPoolRequest) -> Result<models::Operation, Error<CreateDbaasPgConnectionPoolError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_pg_connection_pool_request = create_dbaas_pg_connection_pool_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_pg_connection_pool_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{service_name}/connection-pool",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_pg_database(configuration: &configuration::Configuration, service_name: &str, create_dbaas_pg_database_request: models::CreateDbaasPgDatabaseRequest) -> Result<models::Operation, Error<CreateDbaasPgDatabaseError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_pg_database_request = create_dbaas_pg_database_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_pg_database_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{service_name}/database",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_pg_upgrade_check(configuration: &configuration::Configuration, service: &str, create_dbaas_pg_upgrade_check_request: models::CreateDbaasPgUpgradeCheckRequest) -> Result<models::DbaasTask, Error<CreateDbaasPgUpgradeCheckError>> {
    let local_var_service = service;
    let local_var_create_dbaas_pg_upgrade_check_request = create_dbaas_pg_upgrade_check_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service".to_string(), crate::apis::urlencode(local_var_service));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_pg_upgrade_check_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{service}/upgrade-check",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_postgres_user(configuration: &configuration::Configuration, service_name: &str, create_dbaas_postgres_user_request: models::CreateDbaasPostgresUserRequest) -> Result<models::Operation, Error<CreateDbaasPostgresUserError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_postgres_user_request = create_dbaas_postgres_user_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_postgres_user_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{service_name}/user",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_grafana(configuration: &configuration::Configuration, name: &str, create_dbaas_service_grafana_request: models::CreateDbaasServiceGrafanaRequest) -> Result<models::Operation, Error<CreateDbaasServiceGrafanaError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_grafana_request = create_dbaas_service_grafana_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_grafana_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-grafana/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_kafka(configuration: &configuration::Configuration, name: &str, create_dbaas_service_kafka_request: models::CreateDbaasServiceKafkaRequest) -> Result<models::Operation, Error<CreateDbaasServiceKafkaError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_kafka_request = create_dbaas_service_kafka_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_kafka_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-kafka/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_mysql(configuration: &configuration::Configuration, name: &str, create_dbaas_service_mysql_request: models::CreateDbaasServiceMysqlRequest) -> Result<models::Operation, Error<CreateDbaasServiceMysqlError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_mysql_request = create_dbaas_service_mysql_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_mysql_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-mysql/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_opensearch(configuration: &configuration::Configuration, name: &str, create_dbaas_service_opensearch_request: models::CreateDbaasServiceOpensearchRequest) -> Result<models::Operation, Error<CreateDbaasServiceOpensearchError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_opensearch_request = create_dbaas_service_opensearch_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_opensearch_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-opensearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_pg(configuration: &configuration::Configuration, name: &str, create_dbaas_service_pg_request: models::CreateDbaasServicePgRequest) -> Result<models::Operation, Error<CreateDbaasServicePgError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_pg_request = create_dbaas_service_pg_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_pg_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_service_valkey(configuration: &configuration::Configuration, name: &str, create_dbaas_service_valkey_request: models::CreateDbaasServiceValkeyRequest) -> Result<models::Operation, Error<CreateDbaasServiceValkeyError>> {
    let local_var_name = name;
    let local_var_create_dbaas_service_valkey_request = create_dbaas_service_valkey_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_service_valkey_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-valkey/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_task_migration_check(configuration: &configuration::Configuration, service: &str, create_dbaas_task_migration_check_request: models::CreateDbaasTaskMigrationCheckRequest) -> Result<models::Operation, Error<CreateDbaasTaskMigrationCheckError>> {
    let local_var_service = service;
    let local_var_create_dbaas_task_migration_check_request = create_dbaas_task_migration_check_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service".to_string(), crate::apis::urlencode(local_var_service));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_task_migration_check_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-task-migration-check/{service}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn create_dbaas_valkey_user(configuration: &configuration::Configuration, service_name: &str, create_dbaas_kafka_user_request: models::CreateDbaasKafkaUserRequest) -> Result<models::Operation, Error<CreateDbaasValkeyUserError>> {
    let local_var_service_name = service_name;
    let local_var_create_dbaas_kafka_user_request = create_dbaas_kafka_user_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_create_dbaas_kafka_user_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-valkey/{service_name}/user",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_external_endpoint_datadog(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::Operation, Error<DeleteDbaasExternalEndpointDatadogError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-external-endpoint-datadog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_external_endpoint_elasticsearch(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::Operation, Error<DeleteDbaasExternalEndpointElasticsearchError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-external-endpoint-elasticsearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_external_endpoint_opensearch(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::Operation, Error<DeleteDbaasExternalEndpointOpensearchError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-external-endpoint-opensearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_external_endpoint_prometheus(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::Operation, Error<DeleteDbaasExternalEndpointPrometheusError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-external-endpoint-prometheus/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_external_endpoint_rsyslog(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::Operation, Error<DeleteDbaasExternalEndpointRsyslogError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-external-endpoint-rsyslog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_integration(configuration: &configuration::Configuration, id: String) -> Result<models::Operation, Error<DeleteDbaasIntegrationError>> {
    let local_var_id = id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("id".to_string(), crate::apis::urlencode(local_var_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-integration/{id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_kafka_schema_registry_acl_config(configuration: &configuration::Configuration, name: &str, acl_id: &str) -> Result<models::Operation, Error<DeleteDbaasKafkaSchemaRegistryAclConfigError>> {
    let local_var_name = name;
    let local_var_acl_id = acl_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));
                path_params_map.insert("acl_id".to_string(), crate::apis::urlencode(local_var_acl_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-kafka/{name}/schema-registry/acl-config/{acl_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_kafka_topic_acl_config(configuration: &configuration::Configuration, name: &str, acl_id: &str) -> Result<models::Operation, Error<DeleteDbaasKafkaTopicAclConfigError>> {
    let local_var_name = name;
    let local_var_acl_id = acl_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));
                path_params_map.insert("acl_id".to_string(), crate::apis::urlencode(local_var_acl_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-kafka/{name}/topic/acl-config/{acl_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_kafka_user(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::Operation, Error<DeleteDbaasKafkaUserError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-kafka/{service_name}/user/{username}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_mysql_database(configuration: &configuration::Configuration, service_name: &str, database_name: &str) -> Result<models::Operation, Error<DeleteDbaasMysqlDatabaseError>> {
    let local_var_service_name = service_name;
    let local_var_database_name = database_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("database_name".to_string(), crate::apis::urlencode(local_var_database_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-mysql/{service_name}/database/{database_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_mysql_user(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::Operation, Error<DeleteDbaasMysqlUserError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-mysql/{service_name}/user/{username}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_opensearch_user(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::Operation, Error<DeleteDbaasOpensearchUserError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-opensearch/{service_name}/user/{username}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_pg_connection_pool(configuration: &configuration::Configuration, service_name: &str, connection_pool_name: &str) -> Result<models::Operation, Error<DeleteDbaasPgConnectionPoolError>> {
    let local_var_service_name = service_name;
    let local_var_connection_pool_name = connection_pool_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("connection_pool_name".to_string(), crate::apis::urlencode(local_var_connection_pool_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-postgres/{service_name}/connection-pool/{connection_pool_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_pg_database(configuration: &configuration::Configuration, service_name: &str, database_name: &str) -> Result<models::Operation, Error<DeleteDbaasPgDatabaseError>> {
    let local_var_service_name = service_name;
    let local_var_database_name = database_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("database_name".to_string(), crate::apis::urlencode(local_var_database_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-postgres/{service_name}/database/{database_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_postgres_user(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::Operation, Error<DeleteDbaasPostgresUserError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-postgres/{service_name}/user/{username}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-service/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_grafana(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceGrafanaError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-grafana/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_kafka(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceKafkaError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-kafka/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_mysql(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceMysqlError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-mysql/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_opensearch(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceOpensearchError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-opensearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_pg(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServicePgError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-postgres/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_service_valkey(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<DeleteDbaasServiceValkeyError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-valkey/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn delete_dbaas_valkey_user(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::Operation, Error<DeleteDbaasValkeyUserError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::DELETE,
    "/dbaas-valkey/{service_name}/user/{username}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn detach_dbaas_service_from_endpoint(configuration: &configuration::Configuration, source_service_name: &str, detach_dbaas_service_from_endpoint_request: models::DetachDbaasServiceFromEndpointRequest) -> Result<models::Operation, Error<DetachDbaasServiceFromEndpointError>> {
    let local_var_source_service_name = source_service_name;
    let local_var_detach_dbaas_service_from_endpoint_request = detach_dbaas_service_from_endpoint_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("source_service_name".to_string(), crate::apis::urlencode(local_var_source_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_detach_dbaas_service_from_endpoint_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint/{source_service_name}/detach",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn enable_dbaas_mysql_writes(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<EnableDbaasMysqlWritesError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-mysql/{name}/enable/writes",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_ca_certificate(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasCaCertificate200Response, Error<GetDbaasCaCertificateError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-ca-certificate",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_endpoint_datadog(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::DbaasExternalEndpointDatadogOutput, Error<GetDbaasExternalEndpointDatadogError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-datadog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_endpoint_elasticsearch(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::DbaasEndpointElasticsearchOutput, Error<GetDbaasExternalEndpointElasticsearchError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-elasticsearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_endpoint_opensearch(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::DbaasEndpointOpensearchOutput, Error<GetDbaasExternalEndpointOpensearchError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-opensearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_endpoint_prometheus(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::DbaasEndpointExternalPrometheusOutput, Error<GetDbaasExternalEndpointPrometheusError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-prometheus/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_endpoint_rsyslog(configuration: &configuration::Configuration, endpoint_id: String) -> Result<models::DbaasExternalEndpointRsyslogOutput, Error<GetDbaasExternalEndpointRsyslogError>> {
    let local_var_endpoint_id = endpoint_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-rsyslog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_integration(configuration: &configuration::Configuration, integration_id: String) -> Result<models::DbaasExternalIntegration, Error<GetDbaasExternalIntegrationError>> {
    let local_var_integration_id = integration_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("integration_id".to_string(), crate::apis::urlencode(local_var_integration_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-integration/{integration_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_external_integration_settings_datadog(configuration: &configuration::Configuration, integration_id: String) -> Result<models::GetDbaasExternalIntegrationSettingsDatadog200Response, Error<GetDbaasExternalIntegrationSettingsDatadogError>> {
    let local_var_integration_id = integration_id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("integration_id".to_string(), crate::apis::urlencode(local_var_integration_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-integration-settings-datadog/{integration_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_integration(configuration: &configuration::Configuration, id: String) -> Result<models::DbaasIntegration, Error<GetDbaasIntegrationError>> {
    let local_var_id = id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("id".to_string(), crate::apis::urlencode(local_var_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-integration/{id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_kafka_acl_config(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasKafkaAcls, Error<GetDbaasKafkaAclConfigError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-kafka/{name}/acl-config",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_migration_status(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasMigrationStatus, Error<GetDbaasMigrationStatusError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-migration-status/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_opensearch_acl_config(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasOpensearchAclConfig, Error<GetDbaasOpensearchAclConfigError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-opensearch/{name}/acl-config",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_grafana(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServiceGrafana, Error<GetDbaasServiceGrafanaError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-grafana/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_kafka(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServiceKafka, Error<GetDbaasServiceKafkaError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-kafka/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_logs(configuration: &configuration::Configuration, service_name: &str, get_dbaas_service_logs_request: models::GetDbaasServiceLogsRequest) -> Result<models::DbaasServiceLogs, Error<GetDbaasServiceLogsError>> {
    let local_var_service_name = service_name;
    let local_var_get_dbaas_service_logs_request = get_dbaas_service_logs_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_get_dbaas_service_logs_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-service-logs/{service_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_metrics(configuration: &configuration::Configuration, service_name: &str, get_dbaas_service_metrics_request: models::GetDbaasServiceMetricsRequest) -> Result<models::GetDbaasServiceMetrics200Response, Error<GetDbaasServiceMetricsError>> {
    let local_var_service_name = service_name;
    let local_var_get_dbaas_service_metrics_request = get_dbaas_service_metrics_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_get_dbaas_service_metrics_request);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-service-metrics/{service_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_mysql(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServiceMysql, Error<GetDbaasServiceMysqlError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-mysql/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_opensearch(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServiceOpensearch, Error<GetDbaasServiceOpensearchError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-opensearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_pg(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServicePg, Error<GetDbaasServicePgError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-postgres/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_type(configuration: &configuration::Configuration, service_type_name: &str) -> Result<models::DbaasServiceType, Error<GetDbaasServiceTypeError>> {
    let local_var_service_type_name = service_type_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_type_name".to_string(), crate::apis::urlencode(local_var_service_type_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-service-type/{service_type_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_service_valkey(configuration: &configuration::Configuration, name: &str) -> Result<models::DbaasServiceValkey, Error<GetDbaasServiceValkeyError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-valkey/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_grafana(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsGrafana200Response, Error<GetDbaasSettingsGrafanaError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-grafana",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_kafka(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsKafka200Response, Error<GetDbaasSettingsKafkaError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-kafka",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_mysql(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsMysql200Response, Error<GetDbaasSettingsMysqlError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-mysql",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_opensearch(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsOpensearch200Response, Error<GetDbaasSettingsOpensearchError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-opensearch",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_pg(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsPg200Response, Error<GetDbaasSettingsPgError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-pg",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_settings_valkey(configuration: &configuration::Configuration, ) -> Result<models::GetDbaasSettingsValkey200Response, Error<GetDbaasSettingsValkeyError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-settings-valkey",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn get_dbaas_task(configuration: &configuration::Configuration, service: &str, id: String) -> Result<models::DbaasTask, Error<GetDbaasTaskError>> {
    let local_var_service = service;
    let local_var_id = id;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service".to_string(), crate::apis::urlencode(local_var_service));
                path_params_map.insert("id".to_string(), crate::apis::urlencode(local_var_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-task/{service}/{id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_external_endpoint_types(configuration: &configuration::Configuration, ) -> Result<models::ListDbaasExternalEndpointTypes200Response, Error<ListDbaasExternalEndpointTypesError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoint-types",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_external_endpoints(configuration: &configuration::Configuration, ) -> Result<models::ListDbaasExternalEndpoints200Response, Error<ListDbaasExternalEndpointsError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-endpoints",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_external_integrations(configuration: &configuration::Configuration, service_name: &str) -> Result<models::ListDbaasExternalIntegrations200Response, Error<ListDbaasExternalIntegrationsError>> {
    let local_var_service_name = service_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-external-integrations/{service_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_integration_settings(configuration: &configuration::Configuration, integration_type: &str, source_type: &str, dest_type: &str) -> Result<models::ListDbaasIntegrationSettings200Response, Error<ListDbaasIntegrationSettingsError>> {
    let local_var_integration_type = integration_type;
    let local_var_source_type = source_type;
    let local_var_dest_type = dest_type;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("integration_type".to_string(), crate::apis::urlencode(local_var_integration_type));
                path_params_map.insert("source_type".to_string(), crate::apis::urlencode(local_var_source_type));
                path_params_map.insert("dest_type".to_string(), crate::apis::urlencode(local_var_dest_type));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-integration-settings/{integration_type}/{source_type}/{dest_type}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_integration_types(configuration: &configuration::Configuration, ) -> Result<models::ListDbaasIntegrationTypes200Response, Error<ListDbaasIntegrationTypesError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-integration-types",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_service_types(configuration: &configuration::Configuration, ) -> Result<models::ListDbaasServiceTypes200Response, Error<ListDbaasServiceTypesError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-service-type",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn list_dbaas_services(configuration: &configuration::Configuration, ) -> Result<models::ListDbaasServices200Response, Error<ListDbaasServicesError>> {

    let path_params_map = std::collections::HashMap::new();

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-service",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_grafana_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_valkey_user_password_request: models::ResetDbaasValkeyUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasGrafanaUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_valkey_user_password_request = reset_dbaas_valkey_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_valkey_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-grafana/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_kafka_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_valkey_user_password_request: models::ResetDbaasValkeyUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasKafkaUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_valkey_user_password_request = reset_dbaas_valkey_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_valkey_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-kafka/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_mysql_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_mysql_user_password_request: models::ResetDbaasMysqlUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasMysqlUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_mysql_user_password_request = reset_dbaas_mysql_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_mysql_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-mysql/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_opensearch_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_valkey_user_password_request: models::ResetDbaasValkeyUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasOpensearchUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_valkey_user_password_request = reset_dbaas_valkey_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_valkey_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-opensearch/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_postgres_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_valkey_user_password_request: models::ResetDbaasValkeyUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasPostgresUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_valkey_user_password_request = reset_dbaas_valkey_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_valkey_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-postgres/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reset_dbaas_valkey_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str, reset_dbaas_valkey_user_password_request: models::ResetDbaasValkeyUserPasswordRequest) -> Result<models::Operation, Error<ResetDbaasValkeyUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_reset_dbaas_valkey_user_password_request = reset_dbaas_valkey_user_password_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_reset_dbaas_valkey_user_password_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-valkey/{service_name}/user/{username}/password/reset",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_grafana_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserGrafanaSecrets, Error<RevealDbaasGrafanaUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-grafana/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_kafka_connect_password(configuration: &configuration::Configuration, service_name: &str) -> Result<models::DbaasUserKafkaConnectSecrets, Error<RevealDbaasKafkaConnectPasswordError>> {
    let local_var_service_name = service_name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-kafka/{service_name}/connect/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_kafka_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserKafkaSecrets, Error<RevealDbaasKafkaUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-kafka/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_mysql_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserMysqlSecrets, Error<RevealDbaasMysqlUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-mysql/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_opensearch_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserOpensearchSecrets, Error<RevealDbaasOpensearchUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-opensearch/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_postgres_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserPostgresSecrets, Error<RevealDbaasPostgresUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-postgres/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn reveal_dbaas_valkey_user_password(configuration: &configuration::Configuration, service_name: &str, username: &str) -> Result<models::DbaasUserValkeySecrets, Error<RevealDbaasValkeyUserPasswordError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::GET,
    "/dbaas-valkey/{service_name}/user/{username}/password/reveal",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_grafana_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasGrafanaMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-grafana/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_kafka_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasKafkaMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-kafka/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_mysql_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasMysqlMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-mysql/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_opensearch_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasOpensearchMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-opensearch/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_pg_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasPgMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-postgres/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn start_dbaas_valkey_maintenance(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StartDbaasValkeyMaintenanceError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-valkey/{name}/maintenance/start",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn stop_dbaas_mysql_migration(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StopDbaasMysqlMigrationError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-mysql/{name}/migration/stop",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn stop_dbaas_pg_migration(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StopDbaasPgMigrationError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-postgres/{name}/migration/stop",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn stop_dbaas_valkey_migration(configuration: &configuration::Configuration, name: &str) -> Result<models::Operation, Error<StopDbaasValkeyMigrationError>> {
    let local_var_name = name;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
        let body_payload_option: Option<()> = None;

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-valkey/{name}/migration/stop",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_endpoint_datadog(configuration: &configuration::Configuration, endpoint_id: String, dbaas_endpoint_datadog_input_update: models::DbaasEndpointDatadogInputUpdate) -> Result<models::Operation, Error<UpdateDbaasExternalEndpointDatadogError>> {
    let local_var_endpoint_id = endpoint_id;
    let local_var_dbaas_endpoint_datadog_input_update = dbaas_endpoint_datadog_input_update;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_datadog_input_update);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint-datadog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_endpoint_elasticsearch(configuration: &configuration::Configuration, endpoint_id: String, dbaas_endpoint_elasticsearch_input_update: models::DbaasEndpointElasticsearchInputUpdate) -> Result<models::Operation, Error<UpdateDbaasExternalEndpointElasticsearchError>> {
    let local_var_endpoint_id = endpoint_id;
    let local_var_dbaas_endpoint_elasticsearch_input_update = dbaas_endpoint_elasticsearch_input_update;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_elasticsearch_input_update);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint-elasticsearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_endpoint_opensearch(configuration: &configuration::Configuration, endpoint_id: String, dbaas_endpoint_opensearch_input_update: models::DbaasEndpointOpensearchInputUpdate) -> Result<models::Operation, Error<UpdateDbaasExternalEndpointOpensearchError>> {
    let local_var_endpoint_id = endpoint_id;
    let local_var_dbaas_endpoint_opensearch_input_update = dbaas_endpoint_opensearch_input_update;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_opensearch_input_update);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint-opensearch/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_endpoint_prometheus(configuration: &configuration::Configuration, endpoint_id: String, dbaas_endpoint_prometheus_payload: models::DbaasEndpointPrometheusPayload) -> Result<models::Operation, Error<UpdateDbaasExternalEndpointPrometheusError>> {
    let local_var_endpoint_id = endpoint_id;
    let local_var_dbaas_endpoint_prometheus_payload = dbaas_endpoint_prometheus_payload;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_prometheus_payload);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint-prometheus/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_endpoint_rsyslog(configuration: &configuration::Configuration, endpoint_id: String, dbaas_endpoint_rsyslog_input_update: models::DbaasEndpointRsyslogInputUpdate) -> Result<models::Operation, Error<UpdateDbaasExternalEndpointRsyslogError>> {
    let local_var_endpoint_id = endpoint_id;
    let local_var_dbaas_endpoint_rsyslog_input_update = dbaas_endpoint_rsyslog_input_update;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("endpoint_id".to_string(), crate::apis::urlencode(local_var_endpoint_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_endpoint_rsyslog_input_update);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-external-endpoint-rsyslog/{endpoint_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_external_integration_settings_datadog(configuration: &configuration::Configuration, integration_id: String, get_dbaas_external_integration_settings_datadog200_response: models::GetDbaasExternalIntegrationSettingsDatadog200Response) -> Result<models::Operation, Error<UpdateDbaasExternalIntegrationSettingsDatadogError>> {
    let local_var_integration_id = integration_id;
    let local_var_get_dbaas_external_integration_settings_datadog200_response = get_dbaas_external_integration_settings_datadog200_response;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("integration_id".to_string(), crate::apis::urlencode(local_var_integration_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_get_dbaas_external_integration_settings_datadog200_response);

    utils::execute_request(
    configuration,
    reqwest::Method::POST,
    "/dbaas-external-integration-settings-datadog/{integration_id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_integration(configuration: &configuration::Configuration, id: String, update_dbaas_integration_request: models::UpdateDbaasIntegrationRequest) -> Result<models::Operation, Error<UpdateDbaasIntegrationError>> {
    let local_var_id = id;
    let local_var_update_dbaas_integration_request = update_dbaas_integration_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("id".to_string(), crate::apis::urlencode(local_var_id));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_integration_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-integration/{id}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_opensearch_acl_config(configuration: &configuration::Configuration, name: &str, dbaas_opensearch_acl_config: models::DbaasOpensearchAclConfig) -> Result<models::Operation, Error<UpdateDbaasOpensearchAclConfigError>> {
    let local_var_name = name;
    let local_var_dbaas_opensearch_acl_config = dbaas_opensearch_acl_config;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_dbaas_opensearch_acl_config);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-opensearch/{name}/acl-config",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_pg_connection_pool(configuration: &configuration::Configuration, service_name: &str, connection_pool_name: &str, update_dbaas_pg_connection_pool_request: models::UpdateDbaasPgConnectionPoolRequest) -> Result<models::Operation, Error<UpdateDbaasPgConnectionPoolError>> {
    let local_var_service_name = service_name;
    let local_var_connection_pool_name = connection_pool_name;
    let local_var_update_dbaas_pg_connection_pool_request = update_dbaas_pg_connection_pool_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("connection_pool_name".to_string(), crate::apis::urlencode(local_var_connection_pool_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_pg_connection_pool_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-postgres/{service_name}/connection-pool/{connection_pool_name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_postgres_allow_replication(configuration: &configuration::Configuration, service_name: &str, username: &str, update_dbaas_postgres_allow_replication_request: models::UpdateDbaasPostgresAllowReplicationRequest) -> Result<models::DbaasPostgresUsers, Error<UpdateDbaasPostgresAllowReplicationError>> {
    let local_var_service_name = service_name;
    let local_var_username = username;
    let local_var_update_dbaas_postgres_allow_replication_request = update_dbaas_postgres_allow_replication_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("service_name".to_string(), crate::apis::urlencode(local_var_service_name));
                path_params_map.insert("username".to_string(), crate::apis::urlencode(local_var_username));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_postgres_allow_replication_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-postgres/{service_name}/user/{username}/allow-replication",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_grafana(configuration: &configuration::Configuration, name: &str, update_dbaas_service_grafana_request: models::UpdateDbaasServiceGrafanaRequest) -> Result<models::Operation, Error<UpdateDbaasServiceGrafanaError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_grafana_request = update_dbaas_service_grafana_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_grafana_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-grafana/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_kafka(configuration: &configuration::Configuration, name: &str, update_dbaas_service_kafka_request: models::UpdateDbaasServiceKafkaRequest) -> Result<models::Operation, Error<UpdateDbaasServiceKafkaError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_kafka_request = update_dbaas_service_kafka_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_kafka_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-kafka/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_mysql(configuration: &configuration::Configuration, name: &str, update_dbaas_service_mysql_request: models::UpdateDbaasServiceMysqlRequest) -> Result<models::Operation, Error<UpdateDbaasServiceMysqlError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_mysql_request = update_dbaas_service_mysql_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_mysql_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-mysql/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_opensearch(configuration: &configuration::Configuration, name: &str, update_dbaas_service_opensearch_request: models::UpdateDbaasServiceOpensearchRequest) -> Result<models::Operation, Error<UpdateDbaasServiceOpensearchError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_opensearch_request = update_dbaas_service_opensearch_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_opensearch_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-opensearch/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_pg(configuration: &configuration::Configuration, name: &str, update_dbaas_service_pg_request: models::UpdateDbaasServicePgRequest) -> Result<models::Operation, Error<UpdateDbaasServicePgError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_pg_request = update_dbaas_service_pg_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_pg_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-postgres/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
pub async fn update_dbaas_service_valkey(configuration: &configuration::Configuration, name: &str, update_dbaas_service_valkey_request: models::UpdateDbaasServiceValkeyRequest) -> Result<models::Operation, Error<UpdateDbaasServiceValkeyError>> {
    let local_var_name = name;
    let local_var_update_dbaas_service_valkey_request = update_dbaas_service_valkey_request;

    let mut path_params_map = std::collections::HashMap::new();
                path_params_map.insert("name".to_string(), crate::apis::urlencode(local_var_name));

    let query_params_vec: Vec<(&str, String)> = Vec::new();
    let query_params_option = if query_params_vec.is_empty() { None } else { Some(query_params_vec.as_slice())};
            let body_payload_option = Some(local_var_update_dbaas_service_valkey_request);

    utils::execute_request(
    configuration,
    reqwest::Method::PUT,
    "/dbaas-valkey/{name}",
    path_params_map,
    query_params_option,
    body_payload_option,
    ).await
}
