/*
 * Exoscale Public API
 *
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;
use crate::sign_request;

/// struct for passing parameters to the method [`create_dbaas_integration`]
#[derive(Clone, Debug)]
pub struct CreateDbaasIntegrationParams {
    pub create_dbaas_integration_request: crate::models::CreateDbaasIntegrationRequest,
}

/// struct for passing parameters to the method [`create_dbaas_kafka_schema_registry_acl_config`]
#[derive(Clone, Debug)]
pub struct CreateDbaasKafkaSchemaRegistryAclConfigParams {
    pub name: String,
    pub dbaas_kafka_schema_registry_acl_entry: crate::models::DbaasKafkaSchemaRegistryAclEntry,
}

/// struct for passing parameters to the method [`create_dbaas_kafka_topic_acl_config`]
#[derive(Clone, Debug)]
pub struct CreateDbaasKafkaTopicAclConfigParams {
    pub name: String,
    pub dbaas_kafka_topic_acl_entry: crate::models::DbaasKafkaTopicAclEntry,
}

/// struct for passing parameters to the method [`create_dbaas_kafka_user`]
#[derive(Clone, Debug)]
pub struct CreateDbaasKafkaUserParams {
    pub service_name: String,
    pub create_dbaas_kafka_user_request: crate::models::CreateDbaasKafkaUserRequest,
}

/// struct for passing parameters to the method [`create_dbaas_mysql_database`]
#[derive(Clone, Debug)]
pub struct CreateDbaasMysqlDatabaseParams {
    pub service_name: String,
    pub create_dbaas_mysql_database_request: crate::models::CreateDbaasMysqlDatabaseRequest,
}

/// struct for passing parameters to the method [`create_dbaas_mysql_user`]
#[derive(Clone, Debug)]
pub struct CreateDbaasMysqlUserParams {
    pub service_name: String,
    pub create_dbaas_mysql_user_request: crate::models::CreateDbaasMysqlUserRequest,
}

/// struct for passing parameters to the method [`create_dbaas_opensearch_user`]
#[derive(Clone, Debug)]
pub struct CreateDbaasOpensearchUserParams {
    pub service_name: String,
    pub create_dbaas_kafka_user_request: crate::models::CreateDbaasKafkaUserRequest,
}

/// struct for passing parameters to the method [`create_dbaas_pg_connection_pool`]
#[derive(Clone, Debug)]
pub struct CreateDbaasPgConnectionPoolParams {
    pub service_name: String,
    pub create_dbaas_pg_connection_pool_request: crate::models::CreateDbaasPgConnectionPoolRequest,
}

/// struct for passing parameters to the method [`create_dbaas_pg_database`]
#[derive(Clone, Debug)]
pub struct CreateDbaasPgDatabaseParams {
    pub service_name: String,
    pub create_dbaas_pg_database_request: crate::models::CreateDbaasPgDatabaseRequest,
}

/// struct for passing parameters to the method [`create_dbaas_pg_upgrade_check`]
#[derive(Clone, Debug)]
pub struct CreateDbaasPgUpgradeCheckParams {
    pub service: String,
    pub create_dbaas_pg_upgrade_check_request: crate::models::CreateDbaasPgUpgradeCheckRequest,
}

/// struct for passing parameters to the method [`create_dbaas_postgres_user`]
#[derive(Clone, Debug)]
pub struct CreateDbaasPostgresUserParams {
    pub service_name: String,
    pub create_dbaas_postgres_user_request: crate::models::CreateDbaasPostgresUserRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_grafana`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServiceGrafanaParams {
    pub name: String,
    pub create_dbaas_service_grafana_request: crate::models::CreateDbaasServiceGrafanaRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_kafka`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServiceKafkaParams {
    pub name: String,
    pub create_dbaas_service_kafka_request: crate::models::CreateDbaasServiceKafkaRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_mysql`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServiceMysqlParams {
    pub name: String,
    pub create_dbaas_service_mysql_request: crate::models::CreateDbaasServiceMysqlRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_opensearch`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServiceOpensearchParams {
    pub name: String,
    pub create_dbaas_service_opensearch_request: crate::models::CreateDbaasServiceOpensearchRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_pg`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServicePgParams {
    pub name: String,
    pub create_dbaas_service_pg_request: crate::models::CreateDbaasServicePgRequest,
}

/// struct for passing parameters to the method [`create_dbaas_service_redis`]
#[derive(Clone, Debug)]
pub struct CreateDbaasServiceRedisParams {
    pub name: String,
    pub create_dbaas_service_redis_request: crate::models::CreateDbaasServiceRedisRequest,
}

/// struct for passing parameters to the method [`create_dbaas_task_migration_check`]
#[derive(Clone, Debug)]
pub struct CreateDbaasTaskMigrationCheckParams {
    pub service: String,
    pub create_dbaas_task_migration_check_request:
        crate::models::CreateDbaasTaskMigrationCheckRequest,
}

/// struct for passing parameters to the method [`delete_dbaas_integration`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasIntegrationParams {
    pub id: String,
}

/// struct for passing parameters to the method [`delete_dbaas_kafka_schema_registry_acl_config`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasKafkaSchemaRegistryAclConfigParams {
    pub name: String,
    pub acl_id: String,
}

/// struct for passing parameters to the method [`delete_dbaas_kafka_topic_acl_config`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasKafkaTopicAclConfigParams {
    pub name: String,
    pub acl_id: String,
}

/// struct for passing parameters to the method [`delete_dbaas_kafka_user`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasKafkaUserParams {
    pub service_name: String,
    pub username: String,
}

/// struct for passing parameters to the method [`delete_dbaas_mysql_database`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasMysqlDatabaseParams {
    pub service_name: String,
    pub database_name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_mysql_user`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasMysqlUserParams {
    pub service_name: String,
    pub username: String,
}

/// struct for passing parameters to the method [`delete_dbaas_opensearch_user`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasOpensearchUserParams {
    pub service_name: String,
    pub username: String,
}

/// struct for passing parameters to the method [`delete_dbaas_pg_connection_pool`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasPgConnectionPoolParams {
    pub service_name: String,
    pub connection_pool_name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_pg_database`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasPgDatabaseParams {
    pub service_name: String,
    pub database_name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_postgres_user`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasPostgresUserParams {
    pub service_name: String,
    pub username: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_grafana`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceGrafanaParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_kafka`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceKafkaParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_mysql`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceMysqlParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_opensearch`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceOpensearchParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_pg`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServicePgParams {
    pub name: String,
}

/// struct for passing parameters to the method [`delete_dbaas_service_redis`]
#[derive(Clone, Debug)]
pub struct DeleteDbaasServiceRedisParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_integration`]
#[derive(Clone, Debug)]
pub struct GetDbaasIntegrationParams {
    pub id: String,
}

/// struct for passing parameters to the method [`get_dbaas_kafka_acl_config`]
#[derive(Clone, Debug)]
pub struct GetDbaasKafkaAclConfigParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_migration_status`]
#[derive(Clone, Debug)]
pub struct GetDbaasMigrationStatusParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_opensearch_acl_config`]
#[derive(Clone, Debug)]
pub struct GetDbaasOpensearchAclConfigParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_grafana`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceGrafanaParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_kafka`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceKafkaParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_logs`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceLogsParams {
    pub service_name: String,
    pub get_dbaas_service_logs_request: crate::models::GetDbaasServiceLogsRequest,
}

/// struct for passing parameters to the method [`get_dbaas_service_metrics`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceMetricsParams {
    pub service_name: String,
    pub get_dbaas_service_metrics_request: crate::models::GetDbaasServiceMetricsRequest,
}

/// struct for passing parameters to the method [`get_dbaas_service_mysql`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceMysqlParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_opensearch`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceOpensearchParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_pg`]
#[derive(Clone, Debug)]
pub struct GetDbaasServicePgParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_redis`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceRedisParams {
    pub name: String,
}

/// struct for passing parameters to the method [`get_dbaas_service_type`]
#[derive(Clone, Debug)]
pub struct GetDbaasServiceTypeParams {
    pub service_type_name: String,
}

/// struct for passing parameters to the method [`get_dbaas_task`]
#[derive(Clone, Debug)]
pub struct GetDbaasTaskParams {
    pub service: String,
    pub id: String,
}

/// struct for passing parameters to the method [`list_dbaas_integration_settings`]
#[derive(Clone, Debug)]
pub struct ListDbaasIntegrationSettingsParams {
    pub integration_type: String,
    pub source_type: String,
    pub dest_type: String,
}

/// struct for passing parameters to the method [`reset_dbaas_kafka_user_password`]
#[derive(Clone, Debug)]
pub struct ResetDbaasKafkaUserPasswordParams {
    pub service_name: String,
    pub username: String,
    pub reset_dbaas_opensearch_user_password_request:
        crate::models::ResetDbaasOpensearchUserPasswordRequest,
}

/// struct for passing parameters to the method [`reset_dbaas_mysql_user_password`]
#[derive(Clone, Debug)]
pub struct ResetDbaasMysqlUserPasswordParams {
    pub service_name: String,
    pub username: String,
    pub reset_dbaas_mysql_user_password_request: crate::models::ResetDbaasMysqlUserPasswordRequest,
}

/// struct for passing parameters to the method [`reset_dbaas_opensearch_user_password`]
#[derive(Clone, Debug)]
pub struct ResetDbaasOpensearchUserPasswordParams {
    pub service_name: String,
    pub username: String,
    pub reset_dbaas_opensearch_user_password_request:
        crate::models::ResetDbaasOpensearchUserPasswordRequest,
}

/// struct for passing parameters to the method [`reset_dbaas_postgres_user_password`]
#[derive(Clone, Debug)]
pub struct ResetDbaasPostgresUserPasswordParams {
    pub service_name: String,
    pub username: String,
    pub reset_dbaas_opensearch_user_password_request:
        crate::models::ResetDbaasOpensearchUserPasswordRequest,
}

/// struct for passing parameters to the method [`start_dbaas_grafana_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasGrafanaMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`start_dbaas_kafka_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasKafkaMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`start_dbaas_mysql_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasMysqlMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`start_dbaas_opensearch_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasOpensearchMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`start_dbaas_pg_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasPgMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`start_dbaas_redis_maintenance`]
#[derive(Clone, Debug)]
pub struct StartDbaasRedisMaintenanceParams {
    pub name: String,
}

/// struct for passing parameters to the method [`stop_dbaas_mysql_migration`]
#[derive(Clone, Debug)]
pub struct StopDbaasMysqlMigrationParams {
    pub name: String,
}

/// struct for passing parameters to the method [`stop_dbaas_pg_migration`]
#[derive(Clone, Debug)]
pub struct StopDbaasPgMigrationParams {
    pub name: String,
}

/// struct for passing parameters to the method [`stop_dbaas_redis_migration`]
#[derive(Clone, Debug)]
pub struct StopDbaasRedisMigrationParams {
    pub name: String,
}

/// struct for passing parameters to the method [`update_dbaas_integration`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasIntegrationParams {
    pub id: String,
    pub update_dbaas_integration_request: crate::models::UpdateDbaasIntegrationRequest,
}

/// struct for passing parameters to the method [`update_dbaas_opensearch_acl_config`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasOpensearchAclConfigParams {
    pub name: String,
    pub dbaas_opensearch_acl_config: crate::models::DbaasOpensearchAclConfig,
}

/// struct for passing parameters to the method [`update_dbaas_pg_connection_pool`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasPgConnectionPoolParams {
    pub service_name: String,
    pub connection_pool_name: String,
    pub update_dbaas_pg_connection_pool_request: crate::models::UpdateDbaasPgConnectionPoolRequest,
}

/// struct for passing parameters to the method [`update_dbaas_postgres_allow_replication`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasPostgresAllowReplicationParams {
    pub service_name: String,
    pub username: String,
    pub update_dbaas_postgres_allow_replication_request:
        crate::models::UpdateDbaasPostgresAllowReplicationRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_grafana`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServiceGrafanaParams {
    pub name: String,
    pub update_dbaas_service_grafana_request: crate::models::UpdateDbaasServiceGrafanaRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_kafka`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServiceKafkaParams {
    pub name: String,
    pub update_dbaas_service_kafka_request: crate::models::UpdateDbaasServiceKafkaRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_mysql`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServiceMysqlParams {
    pub name: String,
    pub update_dbaas_service_mysql_request: crate::models::UpdateDbaasServiceMysqlRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_opensearch`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServiceOpensearchParams {
    pub name: String,
    pub update_dbaas_service_opensearch_request: crate::models::UpdateDbaasServiceOpensearchRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_pg`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServicePgParams {
    pub name: String,
    pub update_dbaas_service_pg_request: crate::models::UpdateDbaasServicePgRequest,
}

/// struct for passing parameters to the method [`update_dbaas_service_redis`]
#[derive(Clone, Debug)]
pub struct UpdateDbaasServiceRedisParams {
    pub name: String,
    pub update_dbaas_service_redis_request: crate::models::UpdateDbaasServiceRedisRequest,
}

/// struct for typed errors of method [`create_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_kafka_schema_registry_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaSchemaRegistryAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_kafka_topic_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaTopicAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_kafka_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasKafkaUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_mysql_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasMysqlDatabaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_mysql_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasMysqlUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_opensearch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasOpensearchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_pg_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgDatabaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_pg_upgrade_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPgUpgradeCheckError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_postgres_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasPostgresUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServicePgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_service_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasServiceRedisError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dbaas_task_migration_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDbaasTaskMigrationCheckError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_kafka_schema_registry_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaSchemaRegistryAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_kafka_topic_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaTopicAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_kafka_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasKafkaUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_mysql_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasMysqlDatabaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_mysql_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasMysqlUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_opensearch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasOpensearchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_pg_database`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPgDatabaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_postgres_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasPostgresUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServicePgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dbaas_service_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDbaasServiceRedisError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_ca_certificate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasCaCertificateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_kafka_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasKafkaAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_migration_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasMigrationStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_opensearch_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasOpensearchAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceLogsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceMetricsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServicePgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceRedisError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_service_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasServiceTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsGrafanaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsKafkaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsMysqlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsOpensearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsPgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_settings_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasSettingsRedisError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_dbaas_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDbaasTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_dbaas_integration_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasIntegrationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_dbaas_integration_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasIntegrationTypesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_dbaas_service_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasServiceTypesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_dbaas_services`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDbaasServicesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_dbaas_kafka_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasKafkaUserPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_dbaas_mysql_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasMysqlUserPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_dbaas_opensearch_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasOpensearchUserPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_dbaas_postgres_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetDbaasPostgresUserPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_grafana_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasGrafanaMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_kafka_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasKafkaMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_mysql_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasMysqlMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_opensearch_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasOpensearchMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_pg_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasPgMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dbaas_redis_maintenance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDbaasRedisMaintenanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_dbaas_mysql_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasMysqlMigrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_dbaas_pg_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasPgMigrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_dbaas_redis_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDbaasRedisMigrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_integration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasIntegrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_opensearch_acl_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasOpensearchAclConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_pg_connection_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasPgConnectionPoolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_postgres_allow_replication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasPostgresAllowReplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_grafana`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceGrafanaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_kafka`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceKafkaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceMysqlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_opensearch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceOpensearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_pg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServicePgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dbaas_service_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDbaasServiceRedisError {
    UnknownValue(serde_json::Value),
}

/// Create a new DBaaS integration between two services
pub async fn create_dbaas_integration(
    configuration: &configuration::Configuration,
    params: CreateDbaasIntegrationParams,
) -> Result<crate::models::Operation, Error<CreateDbaasIntegrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_dbaas_integration_request = params.create_dbaas_integration_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-integration", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_integration_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasIntegrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_kafka_schema_registry_acl_config(
    configuration: &configuration::Configuration,
    params: CreateDbaasKafkaSchemaRegistryAclConfigParams,
) -> Result<crate::models::Operation, Error<CreateDbaasKafkaSchemaRegistryAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let dbaas_kafka_schema_registry_acl_entry = params.dbaas_kafka_schema_registry_acl_entry;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/schema-registry/acl-config",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&dbaas_kafka_schema_registry_acl_entry);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasKafkaSchemaRegistryAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_kafka_topic_acl_config(
    configuration: &configuration::Configuration,
    params: CreateDbaasKafkaTopicAclConfigParams,
) -> Result<crate::models::Operation, Error<CreateDbaasKafkaTopicAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let dbaas_kafka_topic_acl_entry = params.dbaas_kafka_topic_acl_entry;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/topic/acl-config",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&dbaas_kafka_topic_acl_entry);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasKafkaTopicAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_kafka_user(
    configuration: &configuration::Configuration,
    params: CreateDbaasKafkaUserParams,
) -> Result<crate::models::Operation, Error<CreateDbaasKafkaUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_kafka_user_request = params.create_dbaas_kafka_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{service_name}/user",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_kafka_user_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasKafkaUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_mysql_database(
    configuration: &configuration::Configuration,
    params: CreateDbaasMysqlDatabaseParams,
) -> Result<crate::models::Operation, Error<CreateDbaasMysqlDatabaseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_mysql_database_request = params.create_dbaas_mysql_database_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{service_name}/database",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_mysql_database_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasMysqlDatabaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_mysql_user(
    configuration: &configuration::Configuration,
    params: CreateDbaasMysqlUserParams,
) -> Result<crate::models::Operation, Error<CreateDbaasMysqlUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_mysql_user_request = params.create_dbaas_mysql_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{service_name}/user",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_mysql_user_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasMysqlUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_opensearch_user(
    configuration: &configuration::Configuration,
    params: CreateDbaasOpensearchUserParams,
) -> Result<crate::models::Operation, Error<CreateDbaasOpensearchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_kafka_user_request = params.create_dbaas_kafka_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{service_name}/user",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_kafka_user_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasOpensearchUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_dbaas_pg_connection_pool(
    configuration: &configuration::Configuration,
    params: CreateDbaasPgConnectionPoolParams,
) -> Result<crate::models::Operation, Error<CreateDbaasPgConnectionPoolError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_pg_connection_pool_request = params.create_dbaas_pg_connection_pool_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/connection-pool",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_pg_connection_pool_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasPgConnectionPoolError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_pg_database(
    configuration: &configuration::Configuration,
    params: CreateDbaasPgDatabaseParams,
) -> Result<crate::models::Operation, Error<CreateDbaasPgDatabaseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_pg_database_request = params.create_dbaas_pg_database_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/database",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_pg_database_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasPgDatabaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check whether you can upgrade Postgres service to a newer version
pub async fn create_dbaas_pg_upgrade_check(
    configuration: &configuration::Configuration,
    params: CreateDbaasPgUpgradeCheckParams,
) -> Result<crate::models::DbaasTask, Error<CreateDbaasPgUpgradeCheckError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service = params.service;
    let create_dbaas_pg_upgrade_check_request = params.create_dbaas_pg_upgrade_check_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service}/upgrade-check",
        local_var_configuration.base_path,
        service = crate::apis::urlencode(service)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_pg_upgrade_check_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasPgUpgradeCheckError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_postgres_user(
    configuration: &configuration::Configuration,
    params: CreateDbaasPostgresUserParams,
) -> Result<crate::models::Operation, Error<CreateDbaasPostgresUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let create_dbaas_postgres_user_request = params.create_dbaas_postgres_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/user",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_postgres_user_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasPostgresUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS Grafana service
pub async fn create_dbaas_service_grafana(
    configuration: &configuration::Configuration,
    params: CreateDbaasServiceGrafanaParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServiceGrafanaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_grafana_request = params.create_dbaas_service_grafana_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-grafana/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_grafana_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServiceGrafanaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS Kafka service
pub async fn create_dbaas_service_kafka(
    configuration: &configuration::Configuration,
    params: CreateDbaasServiceKafkaParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServiceKafkaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_kafka_request = params.create_dbaas_service_kafka_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_kafka_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServiceKafkaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS MySQL service
pub async fn create_dbaas_service_mysql(
    configuration: &configuration::Configuration,
    params: CreateDbaasServiceMysqlParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServiceMysqlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_mysql_request = params.create_dbaas_service_mysql_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_mysql_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServiceMysqlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS OpenSearch service
pub async fn create_dbaas_service_opensearch(
    configuration: &configuration::Configuration,
    params: CreateDbaasServiceOpensearchParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServiceOpensearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_opensearch_request = params.create_dbaas_service_opensearch_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_opensearch_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServiceOpensearchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_dbaas_service_pg(
    configuration: &configuration::Configuration,
    params: CreateDbaasServicePgParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServicePgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_pg_request = params.create_dbaas_service_pg_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_pg_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServicePgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS Redis service
pub async fn create_dbaas_service_redis(
    configuration: &configuration::Configuration,
    params: CreateDbaasServiceRedisParams,
) -> Result<crate::models::Operation, Error<CreateDbaasServiceRedisError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let create_dbaas_service_redis_request = params.create_dbaas_service_redis_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_service_redis_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasServiceRedisError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a DBaaS task to check migration
pub async fn create_dbaas_task_migration_check(
    configuration: &configuration::Configuration,
    params: CreateDbaasTaskMigrationCheckParams,
) -> Result<crate::models::Operation, Error<CreateDbaasTaskMigrationCheckError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service = params.service;
    let create_dbaas_task_migration_check_request =
        params.create_dbaas_task_migration_check_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-task-migration-check/{service}",
        local_var_configuration.base_path,
        service = crate::apis::urlencode(service)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_dbaas_task_migration_check_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateDbaasTaskMigrationCheckError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a DBaaS Integration
pub async fn delete_dbaas_integration(
    configuration: &configuration::Configuration,
    params: DeleteDbaasIntegrationParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasIntegrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-integration/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasIntegrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_kafka_schema_registry_acl_config(
    configuration: &configuration::Configuration,
    params: DeleteDbaasKafkaSchemaRegistryAclConfigParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasKafkaSchemaRegistryAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let acl_id = params.acl_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/schema-registry/acl-config/{acl_id}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name),
        acl_id = crate::apis::urlencode(acl_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasKafkaSchemaRegistryAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_kafka_topic_acl_config(
    configuration: &configuration::Configuration,
    params: DeleteDbaasKafkaTopicAclConfigParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasKafkaTopicAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let acl_id = params.acl_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/topic/acl-config/{acl_id}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name),
        acl_id = crate::apis::urlencode(acl_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasKafkaTopicAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_kafka_user(
    configuration: &configuration::Configuration,
    params: DeleteDbaasKafkaUserParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasKafkaUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{service_name}/user/{username}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasKafkaUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_mysql_database(
    configuration: &configuration::Configuration,
    params: DeleteDbaasMysqlDatabaseParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasMysqlDatabaseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let database_name = params.database_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{service_name}/database/{database_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        database_name = crate::apis::urlencode(database_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasMysqlDatabaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_mysql_user(
    configuration: &configuration::Configuration,
    params: DeleteDbaasMysqlUserParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasMysqlUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{service_name}/user/{username}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasMysqlUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_opensearch_user(
    configuration: &configuration::Configuration,
    params: DeleteDbaasOpensearchUserParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasOpensearchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{service_name}/user/{username}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasOpensearchUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn delete_dbaas_pg_connection_pool(
    configuration: &configuration::Configuration,
    params: DeleteDbaasPgConnectionPoolParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasPgConnectionPoolError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let connection_pool_name = params.connection_pool_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/connection-pool/{connection_pool_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        connection_pool_name = crate::apis::urlencode(connection_pool_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasPgConnectionPoolError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_pg_database(
    configuration: &configuration::Configuration,
    params: DeleteDbaasPgDatabaseParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasPgDatabaseError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let database_name = params.database_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/database/{database_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        database_name = crate::apis::urlencode(database_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasPgDatabaseError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_postgres_user(
    configuration: &configuration::Configuration,
    params: DeleteDbaasPostgresUserParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasPostgresUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/user/{username}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasPostgresUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a DBaaS service
pub async fn delete_dbaas_service(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-service/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_grafana(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceGrafanaParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceGrafanaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-grafana/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceGrafanaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_kafka(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceKafkaParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceKafkaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceKafkaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_mysql(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceMysqlParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceMysqlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceMysqlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_opensearch(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceOpensearchParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceOpensearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceOpensearchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_pg(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServicePgParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServicePgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServicePgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_dbaas_service_redis(
    configuration: &configuration::Configuration,
    params: DeleteDbaasServiceRedisParams,
) -> Result<crate::models::Operation, Error<DeleteDbaasServiceRedisError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteDbaasServiceRedisError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a CA Certificate required to reach a DBaaS service through a TLS-protected connection.
pub async fn get_dbaas_ca_certificate(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasCaCertificate200Response, Error<GetDbaasCaCertificateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-ca-certificate", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasCaCertificateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS Integration
pub async fn get_dbaas_integration(
    configuration: &configuration::Configuration,
    params: GetDbaasIntegrationParams,
) -> Result<crate::models::DbaasIntegration, Error<GetDbaasIntegrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-integration/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasIntegrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_dbaas_kafka_acl_config(
    configuration: &configuration::Configuration,
    params: GetDbaasKafkaAclConfigParams,
) -> Result<crate::models::DbaasKafkaAcls, Error<GetDbaasKafkaAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/acl-config",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasKafkaAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS migration status
pub async fn get_dbaas_migration_status(
    configuration: &configuration::Configuration,
    params: GetDbaasMigrationStatusParams,
) -> Result<crate::models::DbaasMigrationStatus, Error<GetDbaasMigrationStatusError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-migration-status/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasMigrationStatusError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_dbaas_opensearch_acl_config(
    configuration: &configuration::Configuration,
    params: GetDbaasOpensearchAclConfigParams,
) -> Result<crate::models::DbaasOpensearchAclConfig, Error<GetDbaasOpensearchAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}/acl-config",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasOpensearchAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_dbaas_service_grafana(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceGrafanaParams,
) -> Result<crate::models::DbaasServiceGrafana, Error<GetDbaasServiceGrafanaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-grafana/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceGrafanaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_dbaas_service_kafka(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceKafkaParams,
) -> Result<crate::models::DbaasServiceKafka, Error<GetDbaasServiceKafkaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceKafkaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get logs of DBaaS service
pub async fn get_dbaas_service_logs(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceLogsParams,
) -> Result<crate::models::DbaasServiceLogs, Error<GetDbaasServiceLogsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let get_dbaas_service_logs_request = params.get_dbaas_service_logs_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-service-logs/{service_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&get_dbaas_service_logs_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceLogsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get metrics of DBaaS service
pub async fn get_dbaas_service_metrics(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceMetricsParams,
) -> Result<crate::models::GetDbaasServiceMetrics200Response, Error<GetDbaasServiceMetricsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let get_dbaas_service_metrics_request = params.get_dbaas_service_metrics_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-service-metrics/{service_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&get_dbaas_service_metrics_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceMetricsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS MySQL service
pub async fn get_dbaas_service_mysql(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceMysqlParams,
) -> Result<crate::models::DbaasServiceMysql, Error<GetDbaasServiceMysqlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceMysqlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS OpenSearch service
pub async fn get_dbaas_service_opensearch(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceOpensearchParams,
) -> Result<crate::models::DbaasServiceOpensearch, Error<GetDbaasServiceOpensearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceOpensearchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS PostgreSQL service
pub async fn get_dbaas_service_pg(
    configuration: &configuration::Configuration,
    params: GetDbaasServicePgParams,
) -> Result<crate::models::DbaasServicePg, Error<GetDbaasServicePgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServicePgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS Redis service
pub async fn get_dbaas_service_redis(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceRedisParams,
) -> Result<crate::models::DbaasServiceRedis, Error<GetDbaasServiceRedisError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceRedisError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS service type
pub async fn get_dbaas_service_type(
    configuration: &configuration::Configuration,
    params: GetDbaasServiceTypeParams,
) -> Result<crate::models::DbaasServiceType, Error<GetDbaasServiceTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_type_name = params.service_type_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-service-type/{service_type_name}",
        local_var_configuration.base_path,
        service_type_name = crate::apis::urlencode(service_type_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasServiceTypeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS Grafana settings
pub async fn get_dbaas_settings_grafana(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasSettingsGrafana200Response, Error<GetDbaasSettingsGrafanaError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-settings-grafana",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsGrafanaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS Kafka settings
pub async fn get_dbaas_settings_kafka(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasSettingsKafka200Response, Error<GetDbaasSettingsKafkaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-settings-kafka", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsKafkaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS MySQL settings
pub async fn get_dbaas_settings_mysql(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasSettingsMysql200Response, Error<GetDbaasSettingsMysqlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-settings-mysql", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsMysqlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS OpenSearch settings
pub async fn get_dbaas_settings_opensearch(
    configuration: &configuration::Configuration,
) -> Result<
    crate::models::GetDbaasSettingsOpensearch200Response,
    Error<GetDbaasSettingsOpensearchError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-settings-opensearch",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsOpensearchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS PostgreSQL settings
pub async fn get_dbaas_settings_pg(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasSettingsPg200Response, Error<GetDbaasSettingsPgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-settings-pg", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsPgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the default settings for Redis.
pub async fn get_dbaas_settings_redis(
    configuration: &configuration::Configuration,
) -> Result<crate::models::GetDbaasSettingsRedis200Response, Error<GetDbaasSettingsRedisError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-settings-redis", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasSettingsRedisError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a DBaaS task
pub async fn get_dbaas_task(
    configuration: &configuration::Configuration,
    params: GetDbaasTaskParams,
) -> Result<crate::models::DbaasTask, Error<GetDbaasTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service = params.service;
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-task/{service}/{id}",
        local_var_configuration.base_path,
        service = crate::apis::urlencode(service),
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetDbaasTaskError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS integration settings
pub async fn list_dbaas_integration_settings(
    configuration: &configuration::Configuration,
    params: ListDbaasIntegrationSettingsParams,
) -> Result<
    crate::models::ListDbaasIntegrationSettings200Response,
    Error<ListDbaasIntegrationSettingsError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let integration_type = params.integration_type;
    let source_type = params.source_type;
    let dest_type = params.dest_type;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-integration-settings/{integration_type}/{source_type}/{dest_type}",
        local_var_configuration.base_path,
        integration_type = crate::apis::urlencode(integration_type),
        source_type = crate::apis::urlencode(source_type),
        dest_type = crate::apis::urlencode(dest_type)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListDbaasIntegrationSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get DBaaS integration types
pub async fn list_dbaas_integration_types(
    configuration: &configuration::Configuration,
) -> Result<
    crate::models::ListDbaasIntegrationTypes200Response,
    Error<ListDbaasIntegrationTypesError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-integration-types",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListDbaasIntegrationTypesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List available service types for DBaaS
pub async fn list_dbaas_service_types(
    configuration: &configuration::Configuration,
) -> Result<crate::models::ListDbaasServiceTypes200Response, Error<ListDbaasServiceTypesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-service-type", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListDbaasServiceTypesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List DBaaS services
pub async fn list_dbaas_services(
    configuration: &configuration::Configuration,
) -> Result<crate::models::ListDbaasServices200Response, Error<ListDbaasServicesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/dbaas-service", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListDbaasServicesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If no password is provided one will be generated automatically.
pub async fn reset_dbaas_kafka_user_password(
    configuration: &configuration::Configuration,
    params: ResetDbaasKafkaUserPasswordParams,
) -> Result<crate::models::Operation, Error<ResetDbaasKafkaUserPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;
    let reset_dbaas_opensearch_user_password_request =
        params.reset_dbaas_opensearch_user_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{service_name}/user/{username}/password/reset",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.json(&reset_dbaas_opensearch_user_password_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetDbaasKafkaUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If no password is provided one will be generated automatically.
pub async fn reset_dbaas_mysql_user_password(
    configuration: &configuration::Configuration,
    params: ResetDbaasMysqlUserPasswordParams,
) -> Result<crate::models::Operation, Error<ResetDbaasMysqlUserPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;
    let reset_dbaas_mysql_user_password_request = params.reset_dbaas_mysql_user_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{service_name}/user/{username}/password/reset",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&reset_dbaas_mysql_user_password_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetDbaasMysqlUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If no password is provided one will be generated automatically.
pub async fn reset_dbaas_opensearch_user_password(
    configuration: &configuration::Configuration,
    params: ResetDbaasOpensearchUserPasswordParams,
) -> Result<crate::models::Operation, Error<ResetDbaasOpensearchUserPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;
    let reset_dbaas_opensearch_user_password_request =
        params.reset_dbaas_opensearch_user_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{service_name}/user/{username}/password/reset",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.json(&reset_dbaas_opensearch_user_password_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetDbaasOpensearchUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If no password is provided one will be generated automatically.
pub async fn reset_dbaas_postgres_user_password(
    configuration: &configuration::Configuration,
    params: ResetDbaasPostgresUserPasswordParams,
) -> Result<crate::models::Operation, Error<ResetDbaasPostgresUserPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;
    let reset_dbaas_opensearch_user_password_request =
        params.reset_dbaas_opensearch_user_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/user/{username}/password/reset",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.json(&reset_dbaas_opensearch_user_password_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetDbaasPostgresUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_grafana_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasGrafanaMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasGrafanaMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-grafana/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasGrafanaMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_kafka_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasKafkaMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasKafkaMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasKafkaMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_mysql_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasMysqlMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasMysqlMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasMysqlMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_opensearch_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasOpensearchMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasOpensearchMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasOpensearchMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_pg_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasPgMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasPgMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasPgMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn start_dbaas_redis_maintenance(
    configuration: &configuration::Configuration,
    params: StartDbaasRedisMaintenanceParams,
) -> Result<crate::models::Operation, Error<StartDbaasRedisMaintenanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}/maintenance/start",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartDbaasRedisMaintenanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn stop_dbaas_mysql_migration(
    configuration: &configuration::Configuration,
    params: StopDbaasMysqlMigrationParams,
) -> Result<crate::models::Operation, Error<StopDbaasMysqlMigrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}/migration/stop",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StopDbaasMysqlMigrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn stop_dbaas_pg_migration(
    configuration: &configuration::Configuration,
    params: StopDbaasPgMigrationParams,
) -> Result<crate::models::Operation, Error<StopDbaasPgMigrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}/migration/stop",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StopDbaasPgMigrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn stop_dbaas_redis_migration(
    configuration: &configuration::Configuration,
    params: StopDbaasRedisMigrationParams,
) -> Result<crate::models::Operation, Error<StopDbaasRedisMigrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}/migration/stop",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StopDbaasRedisMigrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a existing DBaaS integration
pub async fn update_dbaas_integration(
    configuration: &configuration::Configuration,
    params: UpdateDbaasIntegrationParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasIntegrationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let update_dbaas_integration_request = params.update_dbaas_integration_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-integration/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_integration_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasIntegrationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_dbaas_opensearch_acl_config(
    configuration: &configuration::Configuration,
    params: UpdateDbaasOpensearchAclConfigParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasOpensearchAclConfigError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let dbaas_opensearch_acl_config = params.dbaas_opensearch_acl_config;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}/acl-config",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&dbaas_opensearch_acl_config);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasOpensearchAclConfigError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn update_dbaas_pg_connection_pool(
    configuration: &configuration::Configuration,
    params: UpdateDbaasPgConnectionPoolParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasPgConnectionPoolError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let connection_pool_name = params.connection_pool_name;
    let update_dbaas_pg_connection_pool_request = params.update_dbaas_pg_connection_pool_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/connection-pool/{connection_pool_name}",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        connection_pool_name = crate::apis::urlencode(connection_pool_name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_pg_connection_pool_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasPgConnectionPoolError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_dbaas_postgres_allow_replication(
    configuration: &configuration::Configuration,
    params: UpdateDbaasPostgresAllowReplicationParams,
) -> Result<crate::models::DbaasPostgresUsers, Error<UpdateDbaasPostgresAllowReplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_name = params.service_name;
    let username = params.username;
    let update_dbaas_postgres_allow_replication_request =
        params.update_dbaas_postgres_allow_replication_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{service_name}/user/{username}/allow-replication",
        local_var_configuration.base_path,
        service_name = crate::apis::urlencode(service_name),
        username = crate::apis::urlencode(username)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.json(&update_dbaas_postgres_allow_replication_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasPostgresAllowReplicationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_dbaas_service_grafana(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServiceGrafanaParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServiceGrafanaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_grafana_request = params.update_dbaas_service_grafana_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-grafana/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_grafana_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServiceGrafanaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a DBaaS Kafka service
pub async fn update_dbaas_service_kafka(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServiceKafkaParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServiceKafkaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_kafka_request = params.update_dbaas_service_kafka_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-kafka/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_kafka_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServiceKafkaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a DBaaS MySQL service
pub async fn update_dbaas_service_mysql(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServiceMysqlParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServiceMysqlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_mysql_request = params.update_dbaas_service_mysql_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-mysql/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_mysql_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServiceMysqlError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a DBaaS OpenSearch service
pub async fn update_dbaas_service_opensearch(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServiceOpensearchParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServiceOpensearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_opensearch_request = params.update_dbaas_service_opensearch_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-opensearch/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_opensearch_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServiceOpensearchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a DBaaS PostgreSQL service
pub async fn update_dbaas_service_pg(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServicePgParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServicePgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_pg_request = params.update_dbaas_service_pg_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-postgres/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_pg_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServicePgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a DBaaS Redis service
pub async fn update_dbaas_service_redis(
    configuration: &configuration::Configuration,
    params: UpdateDbaasServiceRedisParams,
) -> Result<crate::models::Operation, Error<UpdateDbaasServiceRedisError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let name = params.name;
    let update_dbaas_service_redis_request = params.update_dbaas_service_redis_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/dbaas-redis/{name}",
        local_var_configuration.base_path,
        name = crate::apis::urlencode(name)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_dbaas_service_redis_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDbaasServiceRedisError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
