/*
 * Exoscale Public API
 *
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;
use crate::sign_request;

/// struct for passing parameters to the method [`add_instance_protection`]
#[derive(Clone, Debug)]
pub struct AddInstanceProtectionParams {
    pub id: String,
}

/// struct for passing parameters to the method [`create_instance`]
#[derive(Clone, Debug)]
pub struct CreateInstanceParams {
    pub create_instance_request: crate::models::CreateInstanceRequest,
}

/// struct for passing parameters to the method [`create_snapshot`]
#[derive(Clone, Debug)]
pub struct CreateSnapshotParams {
    pub id: String,
}

/// struct for passing parameters to the method [`delete_instance`]
#[derive(Clone, Debug)]
pub struct DeleteInstanceParams {
    pub id: String,
}

/// struct for passing parameters to the method [`get_instance`]
#[derive(Clone, Debug)]
pub struct GetInstanceParams {
    pub id: String,
}

/// struct for passing parameters to the method [`list_instances`]
#[derive(Clone, Debug)]
pub struct ListInstancesParams {
    pub manager_id: Option<String>,
    pub manager_type: Option<String>,
    pub ip_address: Option<String>,
}

/// struct for passing parameters to the method [`reboot_instance`]
#[derive(Clone, Debug)]
pub struct RebootInstanceParams {
    pub id: String,
}

/// struct for passing parameters to the method [`remove_instance_protection`]
#[derive(Clone, Debug)]
pub struct RemoveInstanceProtectionParams {
    pub id: String,
}

/// struct for passing parameters to the method [`reset_instance`]
#[derive(Clone, Debug)]
pub struct ResetInstanceParams {
    pub id: String,
    pub reset_instance_request: crate::models::ResetInstanceRequest,
}

/// struct for passing parameters to the method [`reset_instance_field`]
#[derive(Clone, Debug)]
pub struct ResetInstanceFieldParams {
    pub id: String,
    pub field: String,
}

/// struct for passing parameters to the method [`reset_instance_password`]
#[derive(Clone, Debug)]
pub struct ResetInstancePasswordParams {
    pub id: String,
}

/// struct for passing parameters to the method [`resize_instance_disk`]
#[derive(Clone, Debug)]
pub struct ResizeInstanceDiskParams {
    pub id: String,
    pub resize_instance_disk_request: crate::models::ResizeInstanceDiskRequest,
}

/// struct for passing parameters to the method [`reveal_instance_password`]
#[derive(Clone, Debug)]
pub struct RevealInstancePasswordParams {
    pub id: String,
}

/// struct for passing parameters to the method [`revert_instance_to_snapshot`]
#[derive(Clone, Debug)]
pub struct RevertInstanceToSnapshotParams {
    pub instance_id: String,
    pub revert_instance_to_snapshot_request: crate::models::RevertInstanceToSnapshotRequest,
}

/// struct for passing parameters to the method [`scale_instance`]
#[derive(Clone, Debug)]
pub struct ScaleInstanceParams {
    pub id: String,
    pub scale_instance_request: crate::models::ScaleInstanceRequest,
}

/// struct for passing parameters to the method [`start_instance`]
#[derive(Clone, Debug)]
pub struct StartInstanceParams {
    pub id: String,
    pub start_instance_request: crate::models::StartInstanceRequest,
}

/// struct for passing parameters to the method [`stop_instance`]
#[derive(Clone, Debug)]
pub struct StopInstanceParams {
    pub id: String,
}

/// struct for passing parameters to the method [`update_instance`]
#[derive(Clone, Debug)]
pub struct UpdateInstanceParams {
    pub id: String,
    pub update_instance_request: crate::models::UpdateInstanceRequest,
}

/// struct for typed errors of method [`add_instance_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddInstanceProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_instances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInstancesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reboot_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RebootInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_instance_protection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveInstanceProtectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_instance_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetInstanceFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_instance_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetInstancePasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resize_instance_disk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResizeInstanceDiskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reveal_instance_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevealInstancePasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revert_instance_to_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevertInstanceToSnapshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scale_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScaleInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInstanceError {
    UnknownValue(serde_json::Value),
}

///
pub async fn add_instance_protection(
    configuration: &configuration::Configuration,
    params: AddInstanceProtectionParams,
) -> Result<serde_json::Value, Error<AddInstanceProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:add-protection",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddInstanceProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_instance(
    configuration: &configuration::Configuration,
    params: CreateInstanceParams,
) -> Result<crate::models::Operation, Error<CreateInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_instance_request = params.create_instance_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/instance", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&create_instance_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn create_snapshot(
    configuration: &configuration::Configuration,
    params: CreateSnapshotParams,
) -> Result<crate::models::Operation, Error<CreateSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:create-snapshot",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn delete_instance(
    configuration: &configuration::Configuration,
    params: DeleteInstanceParams,
) -> Result<crate::models::Operation, Error<DeleteInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn get_instance(
    configuration: &configuration::Configuration,
    params: GetInstanceParams,
) -> Result<crate::models::Instance, Error<GetInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn list_instances(
    configuration: &configuration::Configuration,
    params: ListInstancesParams,
) -> Result<crate::models::ListInstances200Response, Error<ListInstancesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let manager_id = params.manager_id;
    let manager_type = params.manager_type;
    let ip_address = params.ip_address;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/instance", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = manager_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("manager_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = manager_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("manager-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ip_address {
        local_var_req_builder =
            local_var_req_builder.query(&[("ip-address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListInstancesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn reboot_instance(
    configuration: &configuration::Configuration,
    params: RebootInstanceParams,
) -> Result<crate::models::Operation, Error<RebootInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:reboot",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RebootInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn remove_instance_protection(
    configuration: &configuration::Configuration,
    params: RemoveInstanceProtectionParams,
) -> Result<serde_json::Value, Error<RemoveInstanceProtectionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:remove-protection",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveInstanceProtectionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This operation re-installs a Compute instance to a base template. If target template is provided it will be used to recreated instance from. Warning: the operation wipes all data stored on the disk.
pub async fn reset_instance(
    configuration: &configuration::Configuration,
    params: ResetInstanceParams,
) -> Result<crate::models::Operation, Error<ResetInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let reset_instance_request = params.reset_instance_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:reset",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&reset_instance_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn reset_instance_field(
    configuration: &configuration::Configuration,
    params: ResetInstanceFieldParams,
) -> Result<crate::models::Operation, Error<ResetInstanceFieldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let field = params.field;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}/{field}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id),
        field = crate::apis::urlencode(field)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetInstanceFieldError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn reset_instance_password(
    configuration: &configuration::Configuration,
    params: ResetInstancePasswordParams,
) -> Result<crate::models::Operation, Error<ResetInstancePasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:reset-password",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResetInstancePasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This operation resizes a Compute instance's disk volume. Note: the disk can only grow, cannot be shrunk.
pub async fn resize_instance_disk(
    configuration: &configuration::Configuration,
    params: ResizeInstanceDiskParams,
) -> Result<crate::models::Operation, Error<ResizeInstanceDiskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let resize_instance_disk_request = params.resize_instance_disk_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:resize-disk",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&resize_instance_disk_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResizeInstanceDiskError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reveal the password used during instance creation or the latest password reset.             This is only available for VMs created against templates having the `password-enabled`             property set to `true`.              Passwords are transiently stored for at most 24 hours and intended to be retrieved shortly after             creation or resets.
pub async fn reveal_instance_password(
    configuration: &configuration::Configuration,
    params: RevealInstancePasswordParams,
) -> Result<crate::models::InstancePassword, Error<RevealInstancePasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:password",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RevealInstancePasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This operation reverts the snapshot to the Compute instance volume, restoring stored data as it was at the time of the snapshot. The Compute instance must be previously stopped.
pub async fn revert_instance_to_snapshot(
    configuration: &configuration::Configuration,
    params: RevertInstanceToSnapshotParams,
) -> Result<crate::models::Operation, Error<RevertInstanceToSnapshotError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let instance_id = params.instance_id;
    let revert_instance_to_snapshot_request = params.revert_instance_to_snapshot_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{instance_id}:revert-snapshot",
        local_var_configuration.base_path,
        instance_id = crate::apis::urlencode(instance_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&revert_instance_to_snapshot_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RevertInstanceToSnapshotError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This operation changes the Compute instance's type. Note: the new Instance Type must be within the same family (e.g. a standard instance cannot be scaled to gpu2 or storage).
pub async fn scale_instance(
    configuration: &configuration::Configuration,
    params: ScaleInstanceParams,
) -> Result<crate::models::Operation, Error<ScaleInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let scale_instance_request = params.scale_instance_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:scale",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&scale_instance_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ScaleInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This operation starts a virtual machine, potentially using a rescue profile if specified
pub async fn start_instance(
    configuration: &configuration::Configuration,
    params: StartInstanceParams,
) -> Result<crate::models::Operation, Error<StartInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let start_instance_request = params.start_instance_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:start",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&start_instance_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StartInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn stop_instance(
    configuration: &configuration::Configuration,
    params: StopInstanceParams,
) -> Result<crate::models::Operation, Error<StopInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}:stop",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StopInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

///
pub async fn update_instance(
    configuration: &configuration::Configuration,
    params: UpdateInstanceParams,
) -> Result<crate::models::Operation, Error<UpdateInstanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let update_instance_request = params.update_instance_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/instance/{id}",
        local_var_configuration.base_path,
        id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&update_instance_request);

    let mut local_var_req = local_var_req_builder.build()?;
    let _ = sign_request(&mut local_var_req, configuration);
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateInstanceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
