/*
 * Exoscale Public API
 *
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 * Generated by: https://openapi-generator.tech
 */
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonSchemaKafkaRest {
    /// Specify the default compression type for producers. This configuration accepts the standard compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'none' which is the default and equivalent to no compression.
    #[serde(
        rename = "producer_compression_type",
        skip_serializing_if = "Option::is_none"
    )]
    pub producer_compression_type: Option<ProducerCompressionType>,
    /// If true, validate that given schema is registered under expected subject name by the used name strategy when producing messages.
    #[serde(
        rename = "name_strategy_validation",
        skip_serializing_if = "Option::is_none"
    )]
    pub name_strategy_validation: Option<bool>,
    /// Name strategy to use when selecting subject for storing schemas
    #[serde(rename = "name_strategy", skip_serializing_if = "Option::is_none")]
    pub name_strategy: Option<NameStrategy>,
    /// If true the consumer's offset will be periodically committed to Kafka in the background
    #[serde(
        rename = "consumer_enable_auto_commit",
        skip_serializing_if = "Option::is_none"
    )]
    pub consumer_enable_auto_commit: Option<bool>,
    /// The number of acknowledgments the producer requires the leader to have received before considering a request complete. If set to 'all' or '-1', the leader will wait for the full set of in-sync replicas to acknowledge the record.
    #[serde(rename = "producer_acks", skip_serializing_if = "Option::is_none")]
    pub producer_acks: Option<ProducerAcks>,
    /// Maximum number of bytes in unencoded message keys and values by a single request
    #[serde(
        rename = "consumer_request_max_bytes",
        skip_serializing_if = "Option::is_none"
    )]
    pub consumer_request_max_bytes: Option<i32>,
    /// The maximum size of a request in bytes. Note that Kafka broker can also cap the record batch size.
    #[serde(
        rename = "producer_max_request_size",
        skip_serializing_if = "Option::is_none"
    )]
    pub producer_max_request_size: Option<i32>,
    /// Maximum number of SimpleConsumers that can be instantiated per broker
    #[serde(
        rename = "simpleconsumer_pool_size_max",
        skip_serializing_if = "Option::is_none"
    )]
    pub simpleconsumer_pool_size_max: Option<i32>,
    /// Wait for up to the given delay to allow batching records together
    #[serde(rename = "producer_linger_ms", skip_serializing_if = "Option::is_none")]
    pub producer_linger_ms: Option<i32>,
    /// The maximum total time to wait for messages for a request if the maximum number of messages has not yet been reached
    #[serde(
        rename = "consumer_request_timeout_ms",
        skip_serializing_if = "Option::is_none"
    )]
    pub consumer_request_timeout_ms: Option<ConsumerRequestTimeoutMs>,
}

impl JsonSchemaKafkaRest {
    pub fn new() -> JsonSchemaKafkaRest {
        JsonSchemaKafkaRest {
            producer_compression_type: None,
            name_strategy_validation: None,
            name_strategy: None,
            consumer_enable_auto_commit: None,
            producer_acks: None,
            consumer_request_max_bytes: None,
            producer_max_request_size: None,
            simpleconsumer_pool_size_max: None,
            producer_linger_ms: None,
            consumer_request_timeout_ms: None,
        }
    }
}
/// Specify the default compression type for producers. This configuration accepts the standard compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'none' which is the default and equivalent to no compression.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProducerCompressionType {
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "snappy")]
    Snappy,
    #[serde(rename = "lz4")]
    Lz4,
    #[serde(rename = "zstd")]
    Zstd,
    #[serde(rename = "none")]
    None,
}

impl Default for ProducerCompressionType {
    fn default() -> ProducerCompressionType {
        Self::Gzip
    }
}
/// Name strategy to use when selecting subject for storing schemas
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum NameStrategy {
    #[serde(rename = "topic_name")]
    TopicName,
    #[serde(rename = "record_name")]
    RecordName,
    #[serde(rename = "topic_record_name")]
    TopicRecordName,
}

impl Default for NameStrategy {
    fn default() -> NameStrategy {
        Self::TopicName
    }
}
/// The number of acknowledgments the producer requires the leader to have received before considering a request complete. If set to 'all' or '-1', the leader will wait for the full set of in-sync replicas to acknowledge the record.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProducerAcks {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "-1")]
    Variant1,
    #[serde(rename = "0")]
    Variant0,
    #[serde(rename = "1")]
    Variant12,
}

impl Default for ProducerAcks {
    fn default() -> ProducerAcks {
        Self::All
    }
}
/// The maximum total time to wait for messages for a request if the maximum number of messages has not yet been reached
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ConsumerRequestTimeoutMs {
    #[serde(rename = "1000")]
    Variant1000,
    #[serde(rename = "15000")]
    Variant15000,
    #[serde(rename = "30000")]
    Variant30000,
}

impl Default for ConsumerRequestTimeoutMs {
    fn default() -> ConsumerRequestTimeoutMs {
        Self::Variant1000
    }
}
